<?xml version="1.0" encoding="UTF-8"?>
<xwikidoc>
<web>GitHubCode</web>
<name>GitHubGroovy</name>
<language></language>
<defaultLanguage>en</defaultLanguage>
<translation>0</translation>
<parent></parent>
<creator>XWiki.Admin</creator>
<author>XWiki.Admin</author>
<customClass></customClass>
<contentAuthor>XWiki.Admin</contentAuthor>
<creationDate>1262300400000</creationDate>
<date>1262300400000</date>
<contentUpdateDate>1262300400000</contentUpdateDate>
<version>1.1</version>
<title></title>
<template></template>
<defaultTemplate></defaultTemplate>
<validationScript></validationScript>
<comment></comment>
<minorEdit>false</minorEdit>
<syntaxId>xwiki/2.0</syntaxId>
<hidden>false</hidden>
<content>
import org.eclipse.egit.github.core.*;
import org.eclipse.egit.github.core.client.*;
import org.eclipse.egit.github.core.service.*;
import org.apache.commons.codec.binary.Base64;
import java.util.Collection;
import java.util.Iterator;
import org.apache.commons.lang.StringUtils;
import com.xpn.xwiki.doc.XWikiDocument;

public class GitHubGroovy {
    def xwiki;
    def context;
    def githubclient;
    def repuser = "";
    def repname = "";
    def reppath = "";
    def defaultspace = "";
    def configdoc;
    def savedlist = "";
    def repository = null;
    def username = "";
    def password = "";
    def defaultDate = "";
    def defaultUser = "";
    def sdebug = "";
    def status = new HashMap();

    public setXWiki(xwiki, context) {
      this.xwiki = xwiki;
      this.context = context;
    }

    public hasProgrammingRights() {
      return xwiki.hasProgrammingRights();
    }

    public setGitHubConfig(page) {
       this.configdoc = xwiki.getDocument(page)
       this.username = configdoc.getValue("username")
       this.password = configdoc.getObject("GitHubCode.GitHubConfigClass").getProperty("password").property.value
       this.repuser = configdoc.getValue("repository_user");
       this.repname = configdoc.getValue("repository_name");
       this.reppath = configdoc.getValue("repository_path");
       this.defaultspace = configdoc.getValue("defaultspace");
       this.savedlist = configdoc.getValue("savedlist");
       this.defaultDate = configdoc.getValue("defaultdate");
       this.defaultUser = configdoc.getValue("defaultuser");
       this.status = getStatus(configdoc.getValue("status"));

      //Basic authentication
      githubclient = new GitHubClient();
      githubclient.setCredentials(username, password);
       
      def rservice = new RepositoryService(githubclient);
      repository = rservice.getRepository(repuser, repname)
 
      debug("Date:" + this.defaultDate);
    }

    public getStatus(status) {
       def smap = new HashMap();
       for (sline in StringUtils.split(status, "\r\n")) {
          def items = sline.split(";");
          smap.put(items[0], [ "xwikiversion" : (items.length&gt;1) ? items[1] : "", "xwikihash" : (items.length&gt;2) ? items[2] : "", "githubversion" : (items.length&gt;3) ? items[3] : "" ])
       }
       return smap;
    }

    public getPageStatus(filePath) {
      return status.get(filePath);
    }

    public saveStatus() {
       def sstatus = "";
       for (key in status.keySet()) {
         def stat = status.get(key);
         sstatus += "${key};${stat.xwikiversion};${stat.xwikihash};${stat.githubversion}\n";
       }
       // only save if changed
       if (status!=configdoc.getValue("status")) {
        configdoc.set("status", sstatus);
        configdoc.save();
       }
    }

    public debug(message) {
       sdebug += message + "\n";
       def cdate = new Date();
       System.out.println("GITHUBAPP ${cdate}: ${message}");
    }

    public getDebug() {
       return this.sdebug;
    }
   
    public getDefaultSpace() {
        return this.defaultspace;
    }

    public getSavedList() {
        return (this.savedlist==null) ? "" : this.savedlist;
    }

    public getFilePath(pagedoc) {
       // get page
        def filePath = pagedoc.getSpace() + "/" + pagedoc.getName();
        def language = pagedoc.getLanguage();
        if (language!=null&amp;&amp;language!="")
          filePath += "." + language;
        filePath += ".xml"
        return filePath;
    }

    public getStatusPath(pagedoc) {
       // get page
        def filePath = pagedoc.getSpace() + "/" + pagedoc.getName();
        def language = pagedoc.getLanguage();
        if (language!=null&amp;&amp;language!="")
          filePath += "." + language;
        return filePath;
    }

    public String getFileContentAsString(sha) {
        def dservice = new DataService(githubclient);
        def blob = dservice.getBlob(repository, sha);
        def githubcontent = new String(Base64.decodeBase64(blob.content.getBytes()));
        return githubcontent;
   }
     
    public String getFileContentAsString(String space, String page, String language) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;&amp;language!="")
          filePath += "." + language;
        filePath += ".xml"
        return "";
   } 

   /*
    public byte[] getFileContent(String space, String page, String language) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;&amp;language!="")
          filePath += "." + language;
        filePath += ".xml"

        def dservice = new DataService(githubclient);
        def blob = dservice.getBlob(repository, treeEntry.sha);
        def githubcontent = new String(Base64.decodeBase64(blob.content.getBytes()));
        return githubcontent.getBytes();
    }
    */

    public getXML(pagedoc) {
        def clonedDoc = pagedoc.document.clone();

        // remove Tag object
        if (clonedDoc.getObject("XWiki.TagClass")) {
          clonedDoc.removeObject(clonedDoc.getObject("XWiki.TagClass"));
        }

        if (defaultUser &amp;&amp; defaultUser!="") {
          clonedDoc.setCreator(defaultUser);
          clonedDoc.setContentAuthor(defaultUser);
          clonedDoc.setAuthor(defaultUser);
        } else {
          clonedDoc.setCreator(clonedDoc.getAuthor());
          clonedDoc.setContentAuthor(clonedDoc.getAuthor());
        }
     
        if (defaultDate &amp;&amp; defaultDate!="") {
          clonedDoc.setCreationDate(defaultDate);
          clonedDoc.setContentUpdateDate(defaultDate);
          clonedDoc.setDate(defaultDate);
          clonedDoc.setVersion("1.1");
        } else {
          clonedDoc.setContentUpdateDate(clonedDoc.getDate())
          clonedDoc.setCreationDate(clonedDoc.getDate())
          clonedDoc.setVersion("1.1");
        }  

        clonedDoc.setComment("");
        clonedDoc.setMinorEdit(false);
        def c = clonedDoc.toXML(true, false, true, false, context.getContext())
        return c.trim().replaceAll("[\r]","");
    }

    public commitFile(pagedoc, message) {
        def c = getXML(pagedoc);
        return setFileContent(pagedoc.getSpace(), pagedoc.getName(), pagedoc.getLanguage(), c, message)
    }

    public commitFiles(pagelist, message) {
        def newSpaces = new ArrayList();
        def newPages = new ArrayList();

        def currentPageData = new HashMap();
        def pagesBySpace = new HashMap();

        def pagename2 = "";

        for (pagename in pagelist) {
           // separate the language particle at the end of the page name from the page fullname. The pagename is of form &lt;docfullname&gt;.&lt;doclanguage&gt;
           def languageSeparator = pagename.lastIndexOf('.');
           if (languageSeparator &lt; 0) {
             def pagefullname = pagename;  
           }
           def pagefullname = pagename.substring(0, languageSeparator);
           def lang = pagename.substring(languageSeparator + 1);
           def pagedoc = xwiki.getDocument(pagefullname);
           // make sure we get the right translations
           if (lang!=null &amp;&amp; lang!="") {
             pagedoc = pagedoc.getTranslatedDocument(lang);
           }
           def space = pagedoc.getSpace();
           def page = pagedoc.getName();
           def language = pagedoc.getLanguage();
           if (!newSpaces.contains(space)) {
             //  if (pathexists) {
             //   newSpaces.add(space);   
             //   debug("Adding to new spaces: ${space}")         
             //  }
           }      
           
           // get page
           def filePath = space + "/" + page;
           if (language!=null&amp;&amp;language!="")
                filePath += "." + language;
           filePath += ".xml"

           /*
           if (fileexits) {
                newPages.add(filePath);                 
                debug("Adding to new pages: ${filePath}")         
           } else {
                debug("Adding to updated pages: ${filePath}")         
                currentPageData.put(filePath, getFileContent(space, page, language))
           }
           */
           
           def pageList = pagesBySpace.get(space);
           if (pageList==null) {
              pageList = new ArrayList();
              pagesBySpace.put(space, pageList);
           }
           pageList.add(pagedoc);
        }

        def committedPages = new ArrayList();      
        def commitInfo = null;

        def dservice = new DataService(githubclient);
        def ref = dservice.getReference(repository, "refs/heads/master");
        def sha = ref.getObject().getSha()
        def tree = dservice.getTree(repository, sha, true);

        try {
         for (space in pagesBySpace.keySet()) {
            if (newSpaces.contains(space)) {      
             // need to create the space
             // editor.addDir(space, null, -1);
            } else {             
            }

            // loop on each page
            for (pagedoc in pagesBySpace.get(space)) {  
              pagename2 = pagedoc.getFullName();
              def page = pagedoc.getName();
              def language = pagedoc.getLanguage();

              // get page path
              def filePath = space + "/" + page;
              if (language!=null&amp;&amp;language!="")
                  filePath += "." + language;
              filePath += ".xml"

              def newXML = getXML(pagedoc);
              def newData = newXML.getBytes();
              debug("Rep id: " + dservice.getId(repository));

              Blob blob = new Blob();
              blob.setContent(newXML);
              blob.setEncoding("utf-8");
              debug("Repository: " + repository);
              def blobSha = dservice.createBlob(repository, blob);

              debug("Create blob: " + blobSha);

              TreeEntry blobTreeEntry = new TreeEntry();
              blobTreeEntry.setPath(reppath + filePath);
              blobTreeEntry.setType("blob");
              blobTreeEntry.setMode("100644");
              blobTreeEntry.setSha(blobSha);

              ArrayList&lt;TreeEntry&gt; treeEntries = new ArrayList&lt;TreeEntry&gt;();
              treeEntries.add(blobTreeEntry);

              Tree currentTree = dservice.getCommit(repository, ref.getObject().getSha()).getTree();
              Tree blobTree = dservice.createTree(repository, treeEntries, currentTree.getSha());      
              debug("Create tree: " + blobTree + " in path " + reppath + filePath);

              CommitUser commitUser = new CommitUser();
              commitUser.setName("Ludovic Dubost");
              commitUser.setEmail("ludovic@xwiki.com");
              commitUser.setDate(new Date());
              
              Commit commit = new Commit();
              // commit.setAuthor(commitUser);
              // commit.setCommitter(commitUser);
              commit.setMessage("test commit");
              commit.setTree(blobTree);
              commit.setParents(Collections.singletonList(new Commit().setSha(ref.getObject().getSha())));

              def newCommit = dservice.createCommit(repository, commit);
              debug("Created commit: " + newCommit);

              TypedResource object = new TypedResource();
              object.setType("commit").setSha(newCommit.getSha());
              ref.setObject(object);
              dservice.editReference(repository, ref, false);

              if (newPages.contains(filePath)) {
                // adding the page
              } else {
                def oldData = currentPageData.get(filePath);

                // updating page

                // updating status to check for changes
                committedPages.add(getStatusPath(pagedoc));
                def pageStatus = status.get(getStatusPath(pagedoc));
                if (pageStatus==null)
                 pageStatus = [ "xwikiversion" : "", "xwikihash" : "", "githubversion" : ""];
                status.put(getStatusPath(pagedoc), pageStatus);
                pageStatus.xwikiversion = "${pagedoc.getVersion()}";
                pageStatus.xwikihash = "${newXML.hashCode()}";
              }
            }
         }
        } catch (Throwable e) {
            e.printStackTrace();
            debug("error preparing commit on page ${pagename2}: " + e.getMessage());
            return null;

        } finally {
           
        }

        // now real commit
        // get the commit revision number and store it
         // we need to save the status
        def rev = ""
         for (def pagepath in committedPages) {
           status.get(pagepath).githubversion = "${rev}";
         }
         saveStatus();
         return commitInfo;
    }

    public setFileContent(String space, String page, String language, String xml, String message) {
        setFileContent(space, page, language, xml, message, null, true);
    }

    public setFileContent(String space, String page, String language, String xml, String message, boolean createDir) {
        // get page
        def filePath = space + "/" + page;
        if (language!=null&amp;&amp;language!="")
          filePath += "." + language;
        filePath += ".xml"


        def c = getFileContentAsString(space, page, language);
        def changed = false;
        if (c==null || !c.equals(xml))
            changed = true;

        if (changed) {
          def editor = repository.getCommitEditor(message, null);
          def commitInfo = null;

          try {
           if (c==null) {
             // page does not exist we need to add it
             debug("Ready to add file ${filePath} with createDir ${createDir}")
             addFile(editor, space, filePath, xml.getBytes(), createDir, true, true)
           } else {
             // content is different we can commit
             // page does not exist we need to add it
             debug("Ready to update file ${filePath}")
             modifyFile(editor, space, filePath, c.getBytes(), xml.getBytes())
           }
          } catch (Throwable e) {
             e.printStackTrace();
             debug("error preparing commit: " + e.getMessage());
             return null;
          } finally {
           /*
            * This is the final point in all editor handling. Only now all that new
            * information previously described with the editor's methods is sent to
            * the server for committing. As a result the server sends the new
            * commit information.
            */
            try {
              commitInfo = editor.closeEdit();  
            } catch (Throwable e) {
             e.printStackTrace();
             debug("error calling closeEdit: " + e.getMessage());
             return null;
            }
          }
          return commitInfo;
        } else {
          // content is the same. do not commit
          debug("content is the same. do not commit");
          return null;
        }
    }


    public getChangedPages(String spaces) {
        return getChangedPages(spaces, "");
    }

    protected checkPage(page, pagedoc, changedMap, samePages, githubEntries) {
           def wikicontent = getXML(pagedoc);


           def wikihash = (wikicontent==null) ? "" : "${wikicontent.hashCode()}";
           
           def filePath = getFilePath(pagedoc);
           def entry = githubEntries.get(filePath);
           debug("Check ${filePath} ${wikihash}");

           if (entry==null || !wikihash.equals(entry.githubhash)) {
            def pageStatus = getPageStatus(getStatusPath(pagedoc));
            if (pageStatus==null) {
               pageStatus = [ "xwikiversion" : pagedoc.getVersion(), "xwikihash" : "", "githubversion" : "", "githubsha" : (entry==null) ? "" : entry.githubsha ];
               status.put(getStatusPath(pagedoc), pageStatus);
            }
            pageStatus.filePath = filePath;
            pageStatus.page = page;
            pageStatus.fullname = pagedoc.fullName;
            pageStatus.language = pagedoc.language
            pageStatus.status = "";
            pageStatus.githubsha = (entry==null) ? "" : entry.githubsha;

            // debug("Checking page ${page} version ${pagedoc.getVersion()} pageStatus ${pageStatus}")

            if (pageStatus.xwikihash=="") {
               def githubsha = (entry==null) ? "" : entry.githubsha;
               if (githubsha=="")
                pageStatus.status = "A";
               else
                pageStatus.status = "?";
            } else if (pagedoc.getVersion().equals(pageStatus.xwikiversion)) {
               // version has not changed in the wikia
               def whash = "${wikicontent.hashCode()}";
               // if the recorded hash is the same then we have a modified version in GitHub
               // otherwise it's a bad state so it's a conflict
               if (whash == pageStatus.xwikihash)
                pageStatus.status = "U";
               else
                pageStatus.status = "C";
            } else {
               def githubsha = (entry==null) ? "" : entry.githubsha;
               if (githubsha=="")
                pageStatus.status = "A";
               else if(pageStatus.githubsha==githubsha) 
                pageStatus.status = "M";
               else
                pageStatus.status = "C";
            }
            changedMap.put(page, pageStatus)
           } else {
             samePages.add(filePath);
             def pageStatus = getPageStatus(getStatusPath(pagedoc));
             if (pageStatus==null) {
                pageStatus = [ "xwikiversion" : "", "xwikihash" : "", "githubversion" : "", , "githubsha" : "" ];
                status.put(getStatusPath(pagedoc), pageStatus);
             }   
             pageStatus.xwikiversion = pagedoc.getVersion();
             pageStatus.xwikihash = wikicontent.hashCode();
             if (entry!=null) {
             	pageStatus.githubversion = entry.githubversion;
                pageStatus.githubsha = entry.githubsha;
             }
           }
    }

    public getChangedPages(String spaces, String savedlist) {
        def changedMap = new TreeMap();
        def githubEntries = getEntries();
        def spaceList = null;
        def samePages = new ArrayList();
        def list;

        if (!savedlist || savedlist=="") {
         spaceList = Arrays.asList(StringUtils.split(spaces," ,"));
         def sspaces = StringUtils.join(spaceList, "','");
         def sql = "select distinct doc.fullName from XWikiDocument as doc where doc.space in ('${sspaces}')";
         debug("Searching for ${sql}");
         list = xwiki.search(sql)
        } else {
         list = StringUtils.split(xwiki.getDocument(savedlist).getValue("list"), "|");
        }

        for (page in list) {
           def pagedoc = xwiki.getDocument(page);
           checkPage(page, pagedoc, changedMap, samePages, githubEntries);
           def transList = pagedoc.getTranslationList();
           for (trans in transList) {
               def tpagedoc = pagedoc.getTranslatedDocument(trans);
               checkPage(page + "." + tpagedoc.language, tpagedoc, changedMap, samePages, githubEntries);
           }
        }
 
        if (spaceList!=null) {
         for (entry in githubEntries.keySet()) {
             def i1 = entry.indexOf("/");
             def i2 = entry.indexOf(".xml");
             def spaceName = (i1==-1) ? entry : entry.substring(0, i1);
             def pageName = (i2==-1) ? entry : entry.substring(i1+1, i2);
             if (spaceList.contains(spaceName)&amp;&amp;!samePages.contains(entry)&amp;&amp;!changedMap.keySet().contains(spaceName + "." + pageName)) {
               changedMap.put(spaceName + "." + pageName, [ "status" : "N", "xwikiversion" : "", "githubversion" : githubEntries.get(entry).githubversion ])
             }
         }
        }
        // saveStatus if changed
        saveStatus();
        return changedMap;
    }

    public updatePages(pageList) {
        def changedMap = new TreeMap();
        def githubEntries = getEntries();

        for (page in pageList) {
           // separate the language particle at the end of the page name from the page fullname. The pagename is of form &lt;docfullname&gt;.&lt;doclanguage&gt;
           def languageSeparator = page.lastIndexOf('.');
           if (languageSeparator &lt; 0) {
             def pagefullname = page;  
           }
           def pagefullname = page.substring(0, languageSeparator);
           def lang = page.substring(languageSeparator + 1);
        
           def pagedoc = xwiki.getDocument(pagefullname);
           if (lang!=null &amp;&amp; lang!="") {
             pagedoc = pagedoc.getTranslatedDocument(lang);
           }
           def wikicontent = getXML(pagedoc);
           def githubcontent = getFileContentAsString(pagedoc.getSpace(), pagedoc.getName(), pagedoc.getLanguage())
           def githubversion = "";
           if (!wikicontent.equals(githubcontent)) {
            def filePath = getFilePath(pagedoc);
            def pageStatus = getPageStatus(getStatusPath(pagedoc));
            if (pageStatus==null) {
               pageStatus = [ "xwikiversion" : pagedoc.getVersion(), "xwikihash" : "", "githubversion" : "" ];
            }
            pageStatus.filePath = filePath;
            pageStatus.page = pagefullname;
            pageStatus.status = "";

            // debug("Checking page ${page} version ${pagedoc.getVersion()} pageStatus ${pageStatus}")
            def needUpdate = false
            def entry = githubEntries.get(filePath);
            githubversion = (entry==null) ? "" : entry.githubversion;

            if (pageStatus.xwikihash=="") {
               if (githubversion!="")
                needUpdate = true;
            } else if (pagedoc.getVersion().equals(pageStatus.xwikiversion)) {
                needUpdate = true;
            } else {
               if (githubversion!="")
                needUpdate = true
               else if(pageStatus.githubversion!=githubversion) 
                needUpdate = true;
            }
 
            if (needUpdate) {
              // updating XWiki document from GitHub
              changedMap.put(pagefullname, pageStatus);
              def archive = pagedoc.document.getDocumentArchive(context.getContext());
              def version = pagedoc.document.getRCSVersion();

              def newdoc = new XWikiDocument();
              newdoc.fromXML(githubcontent);
             
              // check attachments that do not exist in updated pages and delete them to recycle bin
              for (xa in pagedoc.getAttachmentList()) {
                    if (!newdoc.getAttachment(xa.getFilename())) {
                       pagedoc.document.deleteAttachment(xa.attachment, true, context.getContext());
                    }
              }

              // Make sure they are not marked dirty
              for (xa in newdoc.getAttachmentList()) {
                    xa.setMetaDataDirty(false);
                    xa.getAttachment_content().setContentDirty(false);
              }

              // we need to make sure previous history is kept
              newdoc.setDocumentArchive(archive);

              // we need to keep the creator if there was already a document
              if (pagedoc.getCreator()!=null)
               newdoc.setCreator(pagedoc.getCreator());

              // set user and author to current user
              newdoc.setContentAuthor(context.getUser());
              newdoc.setAuthor(context.getUser());

              // we need to make sure no version is added
              if (pagedoc.isNew()) {
                newdoc.setMetaDataDirty(true);
                newdoc.setContentDirty(true);
                newdoc.setRCSVersion(null);
              } else {
                newdoc.setMetaDataDirty(true);
                newdoc.setContentDirty(true);
              }

              // saving document
              xwiki.getXWiki().saveDocument(newdoc, "Updated from GITHUB", context.getContext());

              // saving attachments
              newdoc.saveAllAttachments(false, true, context.getContext());

              // we need to force the saving the document archive.
              if (newdoc.getDocumentArchive() != null) {
                  xwiki.getXWiki().getVersioningStore().saveXWikiDocArchive(newdoc.getDocumentArchive(context.getContext()), true, context.getContext());
              }
 
              // reading the information to set the status
              def newpagedoc = xwiki.getDocument(pagedoc.getFullName());
              def newwikicontent = getXML(pagedoc);
              pageStatus.xwikiversion = pagedoc.getVersion();
              pageStatus.xwikihash = "${newwikicontent.hashCode()}";  
              pageStatus.githubversion = githubversion;    
            }
           }
        } 
        // saveStatus if changed
        saveStatus();
        return changedMap;
    }

    public exportPages(docname, pageList) {
        def export = xwiki.package
        export.setWithVersions(true)
        export.setWithVersions(false)
        export.setName(docname)
        for (page in pageList) {
            export.add(page, 0);
        }
        export.export();
    }

    public getModifiedFiles(rev) {
        return (getModifiedFiles("", rev, "10"));
    }

    public getModifiedFiles2(date, hour) {
        return (getModifiedFiles("", date, hour));
    }
    
    public getModifiedFiles2(dir, date, hour) {
    }

    public getModifiedFiles(dir, rev, max) {
    }

    public getRevisions(dir) {
    }
    
    public listFiles(dir, recursive) {
    }

    public getCommitStatus(prefix, sep, updatedonly) {
        def str = "";
        str += "${prefix}page${sep}language${sep}version${sep}isnew${sep}hash${sep}githubpath${sep}githubversion${sep}githubhash${sep}isdiff\n"

        while (spaceIterator.hasNext()) {
              def space = entry.getName().toString();
              // Collection pageEntries = repository.getDir(space, -1, null, (Collection) null);
              Iterator pageIterator = null;
              while (pageIterator.hasNext()) {
                 def pageEntry = pageIterator.next();
                 def fileName = pageEntry.getName().toString();
                 def i1 = fileName.indexOf(".xml");
                 def pageName = (i1==-1) ? fileName : fileName.substring(0, i1);
                 pageName = space + "." + pageName;
                 def pagedoc = xwiki.getDocument(pageName);
                 def pagexml = getXML(pagedoc);

                 def baos = new ByteArrayOutputStream();
                 // debug("reading file: ${space}/${fileName}")
                 // repository.getFile(space + "/" + fileName, -1, fileProperties, baos);
                 def githubcontent = new String(baos.toByteArray())

                 def version = (pagedoc==null) ? "" : pagedoc.getVersion();
                 def hash = (pagexml==null) ? "" : pagexml.hashCode();
                 def githubversion = pageEntry.getRevision().toString();
                 def githubhash = (githubcontent==null) ? "" : githubcontent.hashCode();

                 def isdiff = !pagexml.equals(githubcontent)
                 if (!updatedonly || !isdiff)
                  str += "${prefix}${pageName}${sep}${pagedoc.getLanguage()}${sep}${version}${sep}${pagedoc.isNew()}${sep}${hash}${sep}${space}/${fileName}${sep}${githubversion}${sep}${githubhash}${sep}${isdiff}\n"
            }
        }
        return str;
    }

    public getEntries() {
        def entries = new HashMap();

        def dservice = new DataService(githubclient);
        def sha = dservice.getReference(repository, "refs/heads/master").getObject().getSha()
        for (treeEntry in dservice.getTree(repository, sha, true).tree) {
          def entryPath = treeEntry.getPath();
          if (entryPath!=null &amp;&amp; entryPath.startsWith(reppath)) {
           def filePath = treeEntry.path.substring(reppath.length());
           def blob = dservice.getBlob(repository, treeEntry.sha);
           def githubcontent = new String(Base64.decodeBase64(blob.content.getBytes())).replaceAll("[\r]","").trim();
           def githubhash = (githubcontent==null) ? "" : githubcontent.hashCode();
           def githubversion = 0;
           entries.put(filePath, [ "githubversion" : githubversion, "githubsha" : treeEntry.sha, "githubhash" : "${githubhash}", "githubcontent" : githubcontent ]);
           debug("Adding: ${filePath}");
          }
        }
        return entries;
    }


    public showXMLDiff(pagedoc, sha) {
        def githubxml = (sha=="") ? "" : getFileContentAsString(sha);
        def xml = getXML(pagedoc);
        if (pagedoc.isNew() &amp;&amp; githubxml == null)
         return "Document does not exist";
        
        if (pagedoc.isNew())
         return "Document does not exist in the wiki"
 
        if (githubxml==null)
         return "Document does not exist in GitHub"
   
        // remove attachment content from xml
        githubxml = githubxml.replaceAll("(?s)&lt;attachment&gt;(.*?)&lt;content&gt;(.*?)&lt;/content&gt;(.*?)&lt;/attachment&gt;", "&lt;attachment&gt;\$1&lt;content&gt;&lt;/content&gt;\$3&lt;/attachment&gt;")
        xml = xml.replaceAll("(?s)&lt;attachment&gt;(.*?)&lt;content&gt;(.*?)&lt;/content&gt;(.*?)&lt;/attachment&gt;",
                      "&lt;attachment&gt;\$1&lt;content&gt;&lt;/content&gt;\$3&lt;/attachment&gt;")
        return xwiki.diff.getDifferencesAsHTML(githubxml, xml, false);
    }

}

</content></xwikidoc>